# secrets store the secret information of the app
import secrets

# Library import
from simpleauth import SimpleAuthHandler

# Internal import
from base import BaseHandler

class LoginHandler(BaseHandler, SimpleAuthHandler):
    # Enable optional OAuth 2.0 CSRF guard
    OAUTH2_CSRF_STATE = True
    
    USER_ATTRS = {
        'facebook' : {
          'id'     : lambda idf: ('avatar_url','http://graph.facebook.com/{0}/picture?type=large'.format(idf)),
          'name'   : 'name',
          'link'   : 'link'
        },
        'google'   : {
          'picture': 'avatar_url',
          'name'   : 'name',
          'link'   : 'link'
        },
        'windows_live': {
          'avatar_url': 'avatar_url',
          'name'      : 'name',
          'link'      : 'link'
        },
        'twitter'  : {
          'profile_image_url': 'avatar_url',
          'screen_name'      : 'name',
          'link'             : 'link'
        },
        'linkedin' : {
          'picture-url'       : 'avatar_url',
          'first-name'        : 'name',
          'public-profile-url': 'link'
        },
    }

    def _on_signin(self, data, auth_info, provider):

        auth_id = '%s:%s' % (provider, data['id'])

        user = self.auth.store.user_model.get_by_auth_id(auth_id)
       
        login_attrs = self._to_user_attrs(data, self.USER_ATTRS[provider])
        
        # Existing user with the authentication id
        if user:
            # Existing users might've changed their profile data so we update our
            # local model anyway. This might result in quite inefficient usage
            # of the Datastore, but we do this anyway for demo purposes.
            #
            # In a real app you could compare _attrs with user's properties fetched
            # from the datastore and update local user in case something's changed.
            user.populate(**login_attrs)
            user.put()
            self.auth.set_session(self.auth.store.user_to_dict(user))
        
        # Not that authentication id
        else:
            # check whether there's a user currently logged in
            # then, create a new user if nobody's signed in, 
            # otherwise add this auth_id to currently logged in user.

            if self.logged_in:
                u = self.current_user
                u.populate(**login_attrs)
                # The following will also do u.put(). Though, in a real app
                # you might want to check the result, which is
                # (boolean, info) tuple where boolean == True indicates success
                # See webapp2_extras.appengine.auth.models.User for details.
                u.add_auth_id(auth_id)
              
            else:
                ok, user = self.auth.store.user_model.create_user(auth_id, **login_attrs)
                if ok:
                    self.auth.set_session(self.auth.store.user_to_dict(user))

        # TODO: goto the home page
        self.redirect('/homepage')

    def logout(self):
        self.auth.unset_session()
        self.redirect('/')

    # TODO: Fixed handle exception
    def handle_exception(self, exception, debug):
        self.render('error.html', {'exception': exception})
    
    # Must have to use Simple Authentication
    def _callback_uri_for(self, provider):
        return self.uri_for('auth_callback', provider=provider, _full=True)
    
    # Must have to use Simple Authentication
    def _get_consumer_info_for(self, provider):
        return secrets.AUTH_CONFIG[provider]
    
    def _to_user_attrs(self, data, attrs_map):
        user_attrs = {}
        for k, v in attrs_map.iteritems():
            attr = (v, data.get(k)) if isinstance(v, str) else v(data.get(k))
            user_attrs.setdefault(*attr)
        
        return user_attrs
